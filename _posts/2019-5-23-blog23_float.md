---
layout: post
title:  "计算机浮点数表示"
date:   2019-05-23 08:59:48 +0800
categories: jekyll update
---

# 计算机浮点数表示

#### 概念

1. 计算机用二进制来表示数,那么就涉及到使用二进制来表示十进制数,在整数的表示都很好,任何的十进制整数都可以用二进制来表示

2. 但是如果换到有小数的时候,二进制该如何表示呢?

#### 二进制小数的表示

1. 十进制小数的表示,可以看出整数位表示的是 10^(n-1),比如下面的十进制就是(^表示指数)

	555.555 = 5\*10^2+5\*10^1+5\*10^0+ 5\*10^-1+5\*10^-2+5\*10^-3
	
2. 那么二进制的小数表示也可以一样

	11.011  = 1 * 2^1 + 1* 2^0 + 0\*2^-1 + 1\*2^-2 + 1\*2^-3 = 3+ 3/8
	
	
3. 会出现一些问题: 比如10进制无法表示 1/3 只能用 0.3333无限循环, 二进制也无法表示 0.2 只能用 0.001100110011这样无限循环,循环的位数越多,越能靠近0.2 。但是计算机中存储的位数是有限的,而且我们还需要考虑如果有整数部分怎么办,还需要抽出一部分的bit来去表示整数。显然这种表示方法是不好的

#### IEEE浮点数表示方式

1. 根据上面所述,我们无法用二进制来精确的表示十进制整数,那么我们就干脆不要去精确表达十进制,而是取一个很接近他的数即可。那么我们可以用 数学中的 底数+指数+正负号去表示一个数,这样,用少量的位数就可以表示一个很大的数或者很小的数，他们范围很广(因为是指数运算,即使1.1也可以变为很大的数)

2. IEEE浮点数具体表示方式

分为三个部分:
	
1. 符号位 负数 1 整数  0 s

2. 尾数 1 - 2的数 n

3. 阶码 (指数) k


c语言中 float  --> 符号位 1 位  尾数 23位  阶码 8位  double 符号位 1 位  尾数 52位  阶码 11位

分为四种格式:
	
1. 格式化的
	
	1. 格式化的阶码不能全为0和1,阶码的实际值 E = e - Bias,其中e是无符号数,Bias为 2^(k-1) - 1,所以float的bias是 2^7 - 1 = 127,其实就是实际的值是指数算出来的值减去Bias的值
	
	2. 尾数 M的值是要最后加上 1,比如 1010101表示的是小数位,那么最终的M 尾数是要前面的二进制小数加上1

2. 非格式化的

	1. 阶码全为 0, 实际的值是 E = 1 - Bias,Bias为 2^(k-1) - 1
	2. 尾数 M 是直接等于二进制小数 不用加 1

3. 无穷大

	1. 阶码全为  1 
	2.  尾数全为 0

4. NaN

	1. 解码全为 1
	2. 尾数 不为 0

#### 为什么阶码是 e - Bias,而不是直接是e呢?

1. 是为了让非格式化浮点数到格式化浮点数的平滑过渡
2. 我们可以通过观察最大的非格式化浮点数和最小的格式化浮点数的值来直观的感受平滑过渡

